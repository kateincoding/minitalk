#+TITLE: Minitalk Organization

* To Do
  SCHEDULED: <2021-08-25 Wed>
  - [X] Study signals
  - [ ] Work diagram
  - [ ] code

* I. Study signals

** What is a signal?
Signals are standardized messages send to a running program to trigger specific behavior (such quitting or error handling). They are a limited form of inter-process communication (IPC), typically used in Unix, Unix-like, and other POSIX-compliant operating systems.

- it shows all the posible signals that we can work
#+BEGIN_SRC
kill -l
#+END_SRC

- to kill a process
#+BEGIN_SRC
kill -SIGSTOP <PID>
#+END_SRC

- to know all the open process that I have <PID>
#+BEGIN_SRC
ps u
#+END_SRC

** List of commands

- write
- [signal](https://man7.org/linux/man-pages/man2/signal.2.html)
- [sigemptyset](https://man7.org/linux/man-pages/man3/sigemptyset.3p.html)
- [sigaddset](https://man7.org/linux/man-pages/man3/sigaddset.3p.html)
- [sigaction](https://man7.org/linux/man-pages/man2/sigaction.2.html)
- kill
- getpid
- malloc
- free
- pause
- sleep
- usleep
- exit

** signal:
#+BEGIN_SRC
#include <signal.h>
typedef void (*sighandler_t)(int);
sighandler_t signal(int signum, sighandler_t handler);
#+END_SRC

Sets the disposition of the signal <signum> to <handler>, which is either <SIG_IGN>, <SIG_DFL>, or the address of a programmer-defined function (a "signal handler").
If the signal signum is delivered to the process, then one of the following happens:
  - If the disposition is set to SIG_IGN, then the signal is ignored.
  - If the disposition is set to SIG_DFL, then the default action associated with the signal (see signal(7)) occurs.
  - If the disposition is set to a function, then first either the disposition is reset to SIG_DFL, or the signal is blocked (see Portability below), and then handler is called with argument signum.  If invocation of the handler caused the signal to be blocked, then the signal is unblocked upon return from the handler.
The signals SIGKILL and SIGSTOP cannot be caught or ignored.

*** Sending a signal
The following system calls and library functions allow the caller to send a signal:
  - [raise(3)]
  Sends a signal to the calling thread.
  - kill(2)
  Sends a signal to a specified process, to all members of a specified process group, or to all processes on the system.
  - pidfd_send_signal(2)
  Sends a signal to a process identified by a PID file descriptor.
  - [killpg(3)](https://man7.org/linux/man-pages/man3/killpg.3.html)
  Sends a signal to all of the members of a specified process group.
  - [pthread_kill(3)](https://man7.org/linux/man-pages/man3/pthread_kill.3.html)
  Sends a signal to a specified POSIX thread in the same process as the caller.
  - [tgkill(2)](https://man7.org/linux/man-pages/man2/tgkill.2.html)
  Sends a signal to a specified thread within a specific process.  (This is the system call used to implement pthread_kill(3).)
  - [sigqueue(3)](https://man7.org/linux/man-pages/man3/sigqueue.3.html)
  Sends a real-time signal with accompanying data to a specified process.

*** Waiting for a signal to be caught
  - [pause(2)](https://man7.org/linux/man-pages/man2/pause.2.html)
  Suspends execution until any signal is caught.
  - [sigsuspend(2)](https://man7.org/linux/man-pages/man2/sigsuspend.2.html)
  Temporarily changes the signal mask (see below) and suspends execution until one of the unmasked signals is caught.

*** Example of avoid ctrl + c:

Important: signal handlers run asynchronously that means that they can interrump your code at any point
That's why is recomendable to use write instead of printf

#+BEGIN_SRC
#include <stdio.h>
#include <unistd.h>
#include <signal.h>

void MySignalHandler(int sig)
{
    write(1,"I don't want to die!\n", 21);
}

int main(void)
{
    signal(SIGINT, &MySignalHandler);
    while(1)
    {
        printf("hiiiii goku\n");
        sleep(2);
    }
    return 0;
}
#+END_SRC

** sigkill
finish a process
#+BEGIN_SRC
kill -SIGKILL <pid>
#+END_SRC

** sigstop
pause a process
#+BEGIN_SRC
kill -SIGSTOP <pid>
#+END_SRC

** sigcont
to continue the process that is in pause
#+BEGIN_SRC
kill -SIGCONT <pid>
#+END_SRC

** [sigemptyset](https://man7.org/linux/man-pages/man3/sigemptyset.3p.html)
- The sigemptyset() function initializes the signal set pointed to by set, such that all signals defined in POSIX.1‚Äê2008 are excluded.
- Return value: Upon successful completion, sigemptyset() shall return 0; otherwise, it shall return -1 and set errno to indicate the error.
#+BEGIN_SRC
#include <signal.h>
int sigemptyset(sigset_t *set);
#+END_SRC

** [sigaddset](https://man7.org/linux/man-pages/man3/sigaddset.3p.html)
- add a signal to a signal set
- The sigaddset() function adds the individual signal specified by the signo to the signal set pointed to by set.
- Return: Upon successful completion, sigaddset() shall return 0; otherwise, it shall return -1 and set errno to indicate the error.
#+BEGIN_SRC
#include <signal.h>
int sigaddset(sigset_t *set, int signo);
#+END_SRC

** [sigaction](https://man7.org/linux/man-pages/man2/sigaction.2.html)
examine and change a signal action
#+BEGIN_SRC
#include <signal.h>

int sigaction(int signum, const struct sigaction *restrict act,
                     struct sigaction *restrict oldact);
#+END_SRC

struct sigaction sa;

- The sigaction() system call is used to change the action taken by a process on receipt of a specific signal.  (See signal(7) for an overview of signals.)
- signum specifies the signal and can be any valid signal except SIGKILL and SIGSTOP.
- If act is non-NULL, the new action for signal signum is installed from act.  If oldact is non-NULL, the previous action is saved in oldact.
- The sigaction structure is defined as something like:
#+BEGIN_SRC
        struct sigaction {
           void     (*sa_handler)(int);
           void     (*sa_sigaction)(int, siginfo_t *, void *);
           sigset_t   sa_mask;
           int        sa_flags;
           void     (*sa_restorer)(void);
        };
#+END_SRC
- Important: If SA_SIGINFO is specified in sa_flags, then sa_sigaction
       (instead of sa_handler) specifies the signal-handling function
       for signum.  This function receives three arguments, as described
       below.

- Return value: sigaction() returns 0 on success; on error, -1 is returned, and errno is set to indicate the error.

#+BEGIN_SRC
#include <stdio.h>
#include <unistd.h>
#include <signal.h>

void MySignalHandler(int sig)
{
    write(STDOUT_FILENO,"I will not die!\n", 16);
}

int main(void)
{
//    signal(SIGINT, &MySignalHandler);

    struct sigaction sa;
    sa.sa_handler = MySignalHandler;

    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);
    while(1)
    {
        printf("hiiiii goku %d\n", getpid());
        sleep(2);
    }
    return 0;
}
#+END_SRC

**  getpid():
#+BEGIN_SRC
printf("this is your pid = %d\n", getpid());
#+END_SRC

* II. Work diagram
SIGUSR1 represents 0 and SIGUSR2 represents 1
Way to communicate between this 2 signals: is to make them represent a binary value each
** Logicalof the program:
- 128 is 10000000. This will be our mask to then compare with "&" and 
*** client:
- Goal: send the message with the pid process
- Convert ASCII character to Binary character
- Signal use

#+BEGIN_SRC
int	send_bits(int pid, char *msg)
{
	int	bitmask;
	int	i;

	bitmask = -1;
	i = 0;
	while(msg[i])
	{
		while(++bitmask < 8)
		{
			if (msg[i] & 0x80 >> bitmask)
				printf("1");
			else
				printf("0");
			usleep(3);
		}
		i++;
	}
	printf("\n");
	return (0);
}
#+END_SRC
